

/*
 * Filename: swc_clock_control.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "swc_clock_control.h"



/* USER CODE START SWC_CLOCK_CONTROL_INCLUDE */
#include "tft.h"
#include "common.h"
#include "intToASCII.h"
#include "clock_statemachine.h"
#include "sc_clock.h"
#include "sc_event.h"
/* USER CODE END SWC_CLOCK_CONTROL_INCLUDE */


#include "sp_common.h"

/* USER CODE START SWC_CLOCK_CONTROL_USERDEFINITIONS */
// Global variable. Flag variable that is set only when the machine is in ISDISPLAY Container state and needs a 1 minute auto increment.
boolean_t increment1Min_st = FALSE;
// Global variable. Flag variable that is set only when the machine is in ISAUTOINCREMENT Widget state and needs an increment every 250 ms.
boolean_t autoIncrement_st = FALSE;

// Macros to set and reset flags
#define SETFLAG(x)      (x = TRUE)
#define RESETFLAG(x)    (x = FALSE)

/**
 * @brief General dispatcher to save the clock states.
 * @brief STATE_Event_t ev              :   Event that occured in the container that must be
                                            parsed to the widget.
 * @brief CLOCK_active_widget_t widget  :   Current active widget, based on whether the 
                                            container is in editing mode for hours or minutes.
 */
static void CLOCK__dispatch_wrapper(    STATE_Event_t			ev,
                                        CLOCK_active_widget_t	widget);

/**
 * @brief Dispatcher when left key is pressed in ISDISPLAYING container state.
 */
static void CLOCK__dispatch_KL_Hours();
/**
 * @brief Dispatcher when right key is pressed in ISEDITINGHOURS container state.
 */
static void CLOCK__dispatch_KR_Hours();
/**
 * @brief Dispatcher when left key is pressed in ISEDITINGHOURS container state.
 */
static void CLOCK__dispatch_KL_HoursMin();
/**
 * @brief Dispatcher when left key is pressed in ISEDITINGMINUTES container state.
 */
static void CLOCK__dispatch_KL_Min();
/**
 * @brief Dispatcher when right key is pressed in ISEDITINGMINUTES container state.
 */
static void CLOCK__dispatch_KR_Min();
/**
 * @brief Dispatcher when long press of right key occurs in ISEDITINGHOURS container state.
 */
static void CLOCK__dispatch_KRLP_Hours();
/**
 * @brief Dispatcher when long press of right key occurs in ISEDITINGMINUTES container state.
 */
static void CLOCK__dispatch_KRLP_Min();
/**
 * @brief Dispatcher for auto increment event of 250ms in ISEDITINGHOURS container state.
 */
static void CLOCK__dispatch_250MS_Hours();
/**
 * @brief Dispatcher for auto increment event of 250ms in ISEDITINGMINUTES container state.
 */
static void CLOCK__dispatch_250MS_Min();
/**
 * @brief Dispatcher for 1 minute increment in ISDISPLAYING container state.
 */
static void CLOCK__increment1Minute();
/**
 * @brief Entry function to ISDISPLAYING container state to set flag for increment at every 1 minute.
 */
static void CLOCK_setIncrement1Min();
/**
 * @brief Exit function from ISDISPLAYING container state to reset flag for increment at every 1 minute.
 */
static void CLOCK_resetIncrement1Min();
/**
 * @brief Action (transition) function from ISDISPLAYING to ISEDITING widget state 
 * that sets the font of the currently active widget.
 */
static void CLOCK__setEditFonts();
/**
 * @brief Action (transition) function from ISEDITING and ISAUTOINCREMENT to ISDISPLAYING
 * widget state that resets the font to display mode.
 */
static void CLOCK__setDisplayFonts();
/**
 * @brief Action function in ISEDITING and ISAUTOINCREMENT widget states 
 * that updates the widget value, depending on the current active widget.
 */
static void CLOCK__incrementWidget();
/**
 * @brief Entry function to ISAUTOINCREMENT widget state to set flag for increment at every 250 ms.
 */
static void CLOCK_setAutoIncrement();
/**
 * @brief Exit function from ISAUTOINCREMENT widget state to reset flag for increment at every 250 ms.
 */
static void CLOCK_resetAutoIncrement();
/**
 * @brief Error handler : sets an error event.
 */
static void CLOCK__errorHandler();
/**
 * @brief Error handler routine : handling of error is done here.
 */
static void CLOCK__errorHandlerRoutine();

//================================CONTAINER==================================
/** ===CLOCK_C_ISDISPLAYING=== */
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_C_ISDISPLAYING_Transitions =
{
/*  Event                       ToState                                  Guard       Action      */
    {EV_KEYLEFT,                STATE_CLOCK_C_ISEDITINGHOURS,            0,          CLOCK__dispatch_KL_Hours},
    {EV_1MIN,                   STATE_CLOCK_C_ISDISPLAYING,              0,          CLOCK__increment1Minute},
};

/** ===CLOCK_C_ISEDITINGHOURS=== */
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_C_ISEDITINGHOURS_Transitions =
{
/*  Event                       ToState                                 Guard       Action      */
    {EV_KEYLEFT,                STATE_CLOCK_C_ISEDITINGMINUTES,         0,          CLOCK__dispatch_KL_HoursMin},
    {EV_KEYRIGHT,               STATE_CLOCK_C_ISEDITINGHOURS,           0,          CLOCK__dispatch_KR_Hours},
    {EV_KEYRIGHTLONGPRESS,      STATE_CLOCK_C_ISEDITINGHOURS,           0,          CLOCK__dispatch_KRLP_Hours},
    {EV_250MS,                  STATE_CLOCK_C_ISEDITINGHOURS,           0,          CLOCK__dispatch_250MS_Hours}
};

/** ===CLOCK_C_ISEDITINGMINUTES=== */
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_C_ISEDITINGMINUTES_Transitions =
{
/*  Event                       ToState                                 Guard       Action      */
    {EV_KEYLEFT,                STATE_CLOCK_C_ISDISPLAYING,             0,          CLOCK__dispatch_KL_Min},
    {EV_KEYRIGHT,               STATE_CLOCK_C_ISEDITINGMINUTES,         0,          CLOCK__dispatch_KR_Min},
    {EV_KEYRIGHTLONGPRESS,      STATE_CLOCK_C_ISEDITINGMINUTES,         0,          CLOCK__dispatch_KRLP_Min},
    {EV_250MS,                  STATE_CLOCK_C_ISEDITINGMINUTES,         0,          CLOCK__dispatch_250MS_Min}
};

/** ===CLOCK_CONTAINER=== */
static const STATE_stateOuterTransitionTable_t CLOCK_Container_Transitions =
{
/*  fromState							Pointer to transition table                      Size of transition table (elements)*/
    {STATE_CLOCK_C_ISDISPLAYING,        &STATE_CLOCK_C_ISDISPLAYING_Transitions,         sizeof(STATE_CLOCK_C_ISDISPLAYING_Transitions)/sizeof(STATE_stateInnerTransition_t)},
    {STATE_CLOCK_C_ISEDITINGMINUTES,    &STATE_CLOCK_C_ISEDITINGMINUTES_Transitions,     sizeof(STATE_CLOCK_C_ISEDITINGMINUTES_Transitions)/sizeof(STATE_stateInnerTransition_t)},
    {STATE_CLOCK_C_ISEDITINGHOURS,      &STATE_CLOCK_C_ISEDITINGHOURS_Transitions,       sizeof(STATE_CLOCK_C_ISEDITINGHOURS_Transitions)/sizeof(STATE_stateInnerTransition_t)}
};

/** ===CLOCK_CONTAINE SIZE=== */
static const uint16_t CLOCK_Container_Transitions_Size  =   sizeof(CLOCK_Container_Transitions)/sizeof(STATE_stateOuterTransition_t);

//================================WIDGET=====================================
/** ===CLOCK_W_ISDISPLAYING=== */
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_W_ISDISPLAYING_Transitions =
{
/*  Event                       ToState                                 Guard       Action      */
    {EV_KEYLEFT,                STATE_CLOCK_W_ISEDITING,                0,          CLOCK__setEditFonts}
};

/** ===CLOCK_W_ISEDITING=== */
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_W_ISEDITING_Transitions =
{
/*  Event                       ToState                                 Guard       Action      */
    {EV_KEYRIGHT,               STATE_CLOCK_W_ISEDITING,                0,          CLOCK__incrementWidget},
    {EV_KEYRIGHTLONGPRESS,      STATE_CLOCK_W_ISAUTOINCREMENT,          0,          0                     },
    {EV_KEYLEFT,                STATE_CLOCK_W_ISDISPLAYING,             0,          CLOCK__setDisplayFonts}
};

/** ===CLOCK_W_ISAUTOINCREMENT=== */
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_W_ISAUTOINCREMENT_Transitions =
{
/*  Event                       ToState                                 Guard       Action      */
    {EV_KEYRIGHT,               STATE_CLOCK_W_ISEDITING,                0,          0},
    {EV_250MS,                  STATE_CLOCK_W_ISAUTOINCREMENT,          0,          CLOCK__incrementWidget},
	#if TESTERROR == 0
    {EV_KEYLEFT,                STATE_CLOCK_W_ISDISPLAYING,             0,          CLOCK__setDisplayFonts}
    #endif
    #if TESTERROR == 1
    {EV_KEYLEFT,                STATE_CLOCK_W_ISDISPLAYING,             0,          CLOCK__errorHandler}
    #endif
};

/** ===CLOCK_WIDGET=== */
static const STATE_stateOuterTransitionTable_t CLOCK_Widget_Transitions =
{
/*  fromState							Pointer to transition table                      Size of transition table (elements)*/
    {STATE_CLOCK_W_ISDISPLAYING,        &STATE_CLOCK_W_ISDISPLAYING_Transitions,         sizeof(STATE_CLOCK_W_ISDISPLAYING_Transitions)/sizeof(STATE_stateInnerTransition_t)},
    {STATE_CLOCK_W_ISEDITING,           &STATE_CLOCK_W_ISEDITING_Transitions,            sizeof(STATE_CLOCK_W_ISEDITING_Transitions)/sizeof(STATE_stateInnerTransition_t)},
    {STATE_CLOCK_W_ISAUTOINCREMENT,     &STATE_CLOCK_W_ISAUTOINCREMENT_Transitions,      sizeof(STATE_CLOCK_W_ISAUTOINCREMENT_Transitions)/sizeof(STATE_stateInnerTransition_t)}
};

/** ===CLOCK_WIDGET SIZE=== */
static const uint16_t CLOCK_Widget_Transitions_Size =   sizeof(CLOCK_Widget_Transitions)/sizeof(STATE_stateOuterTransition_t);

/** ===ACTION TABLE=== */

static const STATE_stateActionTable_t CLOCK_StateActions = {
/*  State                               Entry                       Exit    */
  { STATE_CLOCK_C_ISDISPLAYING,         CLOCK_setIncrement1Min,     CLOCK_resetIncrement1Min},  
  { STATE_CLOCK_W_ISAUTOINCREMENT,      CLOCK_setAutoIncrement,     CLOCK_resetAutoIncrement}
};
static const uint16_t CLOCK_StateActions_size = sizeof(CLOCK_StateActions)/sizeof(STATE_stateAction_t);

/* USER CODE END SWC_CLOCK_CONTROL_USERDEFINITIONS */



/*
* component: swc_CLOCK_control
* cycletime: 0
* description: Runnable for clock control.
* events: ev_event_onData
* name: CLOCK_CONTROL__run
* shortname: 
* signalIN: so_EVENT
* signalOUT: so_CLOCK
* task: tsk_control
*/
void CLOCK_CONTROL__run(RTE_event ev){
	
	/* USER CODE START CLOCK_CONTROL__run */
    // Read the clock object
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    SC_EVENT_data_t event = RTE_SC_EVENT_get(&SO_EVENT_signal);
    
    if(EV_ERROR == event.m_ev)
    {
        // call the error handler routine when an error event is received.
        CLOCK__errorHandlerRoutine();
    }
    else
    {
        // Get fromState
        STATE_State_t state = clock.m_containerState;
        //Call the state machine and process the event
        RC_t result = STATE_processEvent(   CLOCK_Container_Transitions, CLOCK_Container_Transitions_Size,
                                        CLOCK_StateActions, CLOCK_StateActions_size,
                                        event.m_ev, &state);
        // update the fromState after the event has been processed and set the clock.
        clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
        clock.m_containerState = state; 
        RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
    }
    
    // Debugging through verbosity via UART
    
    static char asciiConvert[30];
    
    UART_LOG_PutString("\n");
    intToASCII((uint32_t)clock.m_hours.m_value, (uint8_t*)&asciiConvert, 2);
    UART_LOG_PutString(asciiConvert);
    UART_LOG_PutChar(':');
    intToASCII((uint32_t)clock.m_minutes.m_value, (uint8_t*)&asciiConvert, 2);
    UART_LOG_PutString(asciiConvert);
    UART_LOG_PutString("\n\n\n");
    
    /* USER CODE END CLOCK_CONTROL__run */
}

/*
* component: swc_CLOCK_control
* cycletime: 0
* description: Runnable for control swc initialization
* events: 
* name: CLOCK_CONTROL_init_run
* shortname: init
* signalIN: 
* signalOUT: 
* task: tsk_control
*/
void CLOCK_CONTROL_init_run(RTE_event ev){
	
	/* USER CODE START CLOCK_CONTROL_init_run */
    SC_CLOCK_data_t clock;
    
    clock.m_transitions     =   (STATE_stateOuterTransitionTable_t*)    CLOCK_Container_Transitions;
    clock.m_stateActions    =   (STATE_ActionPtr_t*)                    0;
    clock.m_activeWidget    =                                           CLOCK_NONE;
    
    CLOCK_widget_t widget;
    
    widget.m_state          =                                           STATE_CLOCK_W_ISDISPLAYING;
    widget.m_transitions    =   (STATE_stateInnerTransitionTable_t*)    CLOCK_Widget_Transitions;
    widget.m_stateActions   =   (STATE_stateAction_t*)                  CLOCK_StateActions;
    widget.m_value          =                                           0;
    
    CLOCK_font_t font;
    
    font.foreground         =   WHITE;
    font.background         =   BLACK;
    
    widget.m_font           =   font;
    
    clock.m_hours           =   widget;
    
    widget.m_state          =                                           STATE_CLOCK_W_ISDISPLAYING;
    widget.m_transitions    =   (STATE_stateInnerTransitionTable_t*)    CLOCK_Widget_Transitions;
    widget.m_stateActions   =   (STATE_stateAction_t*)                  CLOCK_StateActions;
    widget.m_value          =                                           0;
    
    font.foreground         =   WHITE;
    font.background         =   BLACK;
    
    widget.m_font           =   font;
    
    clock.m_minutes         =   widget;
    
    STATE_State_t state;
    
    STATE_initState(CLOCK_StateActions, CLOCK_StateActions_size, &state);
    
    clock.m_containerState  =   state;
    
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
    
    // Initialize tft brightness, fore- and backgorund colors and text size.
    TFT_setBacklight(100);
    TFT_setColors(WHITE, BLACK);
    TFT_setTextSize(3);
    
    /* USER CODE END CLOCK_CONTROL_init_run */
}

/* USER CODE START SWC_CLOCK_CONTROL_FUNCTIONS */
/**
 * @brief General dispatcher to save the clock states.
 * @brief STATE_Event_t ev              :   Event that occured in the container that must be
                                            parsed to the widget.
 * @brief CLOCK_active_widget_t widget  :   Current active widget, based on whether the 
                                            container is in editing mode for hours or minutes.
 */
static void CLOCK__dispatch_wrapper(STATE_Event_t ev, CLOCK_active_widget_t widget)
{
    //Read the state object (container)
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    //Set the active widget
    clock.m_activeWidget = widget;
    
    //Write the changed widget back to the clock object
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
    
    //And fire it to the container state machine.
    //The widget state machine will be called by the container actions.
    //We need a local copy of the widget state as the widget object is also changed by the widget actions.
    if(CLOCK_HOURWIDGET == widget)
    {
        CLOCK_State_t localState = clock.m_hours.m_state;

        //Call the state machine.
        RC_t result = STATE_processEvent(   CLOCK_Widget_Transitions, CLOCK_Widget_Transitions_Size,
                                            CLOCK_StateActions, CLOCK_StateActions_size,
                                            ev, &localState);
        
        //Re-read the state object in order to get the changes by the child.
        clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
        
        clock.m_hours.m_state = localState;

        //Write the changed state back to the clock object.
        RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
    }
    else if(CLOCK_MINWIDGET == widget)
    {
        CLOCK_State_t localState = clock.m_minutes.m_state;
        
        //Call the state machine.
        RC_t result = STATE_processEvent(   CLOCK_Widget_Transitions, CLOCK_Widget_Transitions_Size,
                                            CLOCK_StateActions, CLOCK_StateActions_size,
                                            ev, &localState);
        
        //Re-read the state object in order to get the changes by the child.
        clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
        
        clock.m_minutes.m_state = localState;
        
        //Write the changed state back to the clock object.
        RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
    }
}
/**
 * @brief Dispatcher when left key is pressed in ISDISPLAYING container state.
 */
static void CLOCK__dispatch_KL_Hours()
{
    UART_LOG_PutString("CLOCK__dispatch_KL_Hours\n");
    CLOCK__dispatch_wrapper(EV_KEYLEFT, CLOCK_HOURWIDGET);
}
/**
 * @brief Dispatcher when right key is pressed in ISEDITINGHOURS container state.
 */
static void CLOCK__dispatch_KR_Hours()
{
    UART_LOG_PutString("CLOCK__dispatch_KR_Hours\n");
    CLOCK__dispatch_wrapper(EV_KEYRIGHT, CLOCK_HOURWIDGET);
}
/**
 * @brief Dispatcher when left key is pressed in ISEDITINGHOURS container state.
 */
static void CLOCK__dispatch_KL_HoursMin()
{
    UART_LOG_PutString("CLOCK__dispatch_KL_HoursMin\n");
    CLOCK__dispatch_wrapper(EV_KEYLEFT, CLOCK_HOURWIDGET);
    CLOCK__dispatch_wrapper(EV_KEYLEFT, CLOCK_MINWIDGET);
}
/**
 * @brief Dispatcher when left key is pressed in ISEDITINGMINUTES container state.
 */
static void CLOCK__dispatch_KL_Min()
{
    UART_LOG_PutString("CLOCK__dispatch_KL_Minutes\n");
    CLOCK__dispatch_wrapper(EV_KEYLEFT, CLOCK_MINWIDGET);  
}
/**
 * @brief Dispatcher when right key is pressed in ISEDITINGMINUTES container state.
 */
static void CLOCK__dispatch_KR_Min()
{
    UART_LOG_PutString("CLOCK__dispatch_KR_Minutes\n");
    CLOCK__dispatch_wrapper(EV_KEYRIGHT, CLOCK_MINWIDGET);    
}
/**
 * @brief Dispatcher when long press of right key occurs in ISEDITINGHOURS container state.
 */
static void CLOCK__dispatch_KRLP_Hours()
{
    UART_LOG_PutString("CLOCK__dispatch_KRLP_Hours\n");
    CLOCK__dispatch_wrapper(EV_KEYRIGHTLONGPRESS, CLOCK_HOURWIDGET);
    
    // When long press of right key occurs, set the auto-increment event of 250 ms.
    SC_EVENT_data_t ev = RTE_SC_EVENT_get(&SO_EVENT_signal);
    ev.m_ev     = EV_250MS;
    RTE_SC_EVENT_set(&SO_EVENT_signal, ev);
}
/**
 * @brief Dispatcher when long press of right key occurs in ISEDITINGMINUTES container state.
 */
static void CLOCK__dispatch_KRLP_Min()
{
    UART_LOG_PutString("CLOCK__dispatch_KRLP_Min\n");
    CLOCK__dispatch_wrapper(EV_KEYRIGHTLONGPRESS, CLOCK_MINWIDGET);
    
    // When long press of right key occurs, set the auto-increment event of 250 ms.
    SC_EVENT_data_t ev = RTE_SC_EVENT_get(&SO_EVENT_signal);
    ev.m_ev     = EV_250MS;
    RTE_SC_EVENT_set(&SO_EVENT_signal, ev);
}
/**
 * @brief Dispatcher for auto increment event of 250ms in ISEDITINGHOURS container state.
 */
static void CLOCK__dispatch_250MS_Hours()
{
    UART_LOG_PutString("CLOCK__dispatch_250MS_Hours\n");
    CLOCK__dispatch_wrapper(EV_250MS, CLOCK_HOURWIDGET);
}
/**
 * @brief Dispatcher for auto increment event of 250ms in ISEDITINGMINUTES container state.
 */
static void CLOCK__dispatch_250MS_Min()
{
    UART_LOG_PutString("CLOCK__dispatch_250MS_Min\n");
    CLOCK__dispatch_wrapper(EV_250MS, CLOCK_MINWIDGET);
    
}
/**
 * @brief Dispatcher for 1 minute increment in ISDISPLAYING container state.
 */
static void CLOCK__increment1Minute()
{
    UART_LOG_PutString("CLOCK__increment1Minute\n");
	
	//Read the state object (container).
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
	
	uint16_t hh = clock.m_hours.m_value;
	uint16_t mm = clock.m_minutes.m_value;
	
	mm = (mm + 1) % 60;
	hh = (mm == 0)? ((hh + 1) % 24) : hh;
	
    //Write the changed values back to the clock object.
	clock.m_hours.m_value 	= hh;
	clock.m_minutes.m_value	= mm;
	
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
}
/**
 * @brief Entry function to ISDISPLAYING container state to set flag for increment at every 1 minute.
 */
static void CLOCK_setIncrement1Min()
{
    SETFLAG(increment1Min_st);
}
/**
 * @brief Exit function from ISDISPLAYING container state to reset flag for increment at every 1 minute.
 */
static void CLOCK_resetIncrement1Min()
{
    RESETFLAG(increment1Min_st);   
}
/**
 * @brief Action (transition) function from ISDISPLAYING to ISEDITING widget state 
 * that sets the font of the currently active widget.
 */
static void CLOCK__setEditFonts()
{
    UART_LOG_PutString("CLOCK__setEditFonts\n");
    
    //Re-read the state object in order to get the changes by the child.
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    CLOCK_font_t activeFont;
    CLOCK_font_t inactiveFont;
    
    activeFont.foreground   = BLACK;
    activeFont.background   = WHITE;
    
    inactiveFont.foreground = WHITE;
    inactiveFont.background = BLACK;
        
    if(CLOCK_HOURWIDGET == clock.m_activeWidget)
    {
        clock.m_hours.m_font        = activeFont;
        clock.m_minutes.m_font      = inactiveFont;
    }
    
    if(CLOCK_MINWIDGET == clock.m_activeWidget)
    {
        clock.m_hours.m_font        = inactiveFont;
        clock.m_minutes.m_font      = activeFont;
    }
        
    //Write the changed values back to the clock object.
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
}
/**
 * @brief Action (transition) function from ISEDITING and ISAUTOINCREMENT to ISDISPLAYING
 * widget state that resets the font to display mode.
 */
static void CLOCK__setDisplayFonts()
{
    UART_LOG_PutString("CLOCK__setDisplayFonts\n");
    
    //Re-read the state object in order to get the changes by the child.
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    CLOCK_font_t font;
    
    font.foreground = WHITE;
    font.background = BLACK;
        
    clock.m_hours.m_font    = font;
    clock.m_minutes.m_font  = font;
        
    //Write the changed values back to the clock object.
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock); 
}
/**
 * @brief Action function in ISEDITING and ISAUTOINCREMENT widget states 
 * that updates the widget value, depending on the current active widget.
 */
static void CLOCK__incrementWidget()
{
    UART_LOG_PutString("CLOCK__incrementWidget\n");
    
    //Read the state object (container).
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    CLOCK_State_t localState = clock.m_hours.m_state;
    
    // Check if the hours widget is in editing or auto-increment mode.
    if(STATE_CLOCK_W_ISEDITING == localState || STATE_CLOCK_W_ISAUTOINCREMENT == localState)
    {
        clock.m_hours.m_value = (clock.m_hours.m_value + 1) % 24;
    }
    
    localState = clock.m_minutes.m_state;
    
    // Check if the minutes widget is in editing or auto-increment mode.
    if(STATE_CLOCK_W_ISEDITING == localState || STATE_CLOCK_W_ISAUTOINCREMENT == localState)
    {
        clock.m_minutes.m_value = (clock.m_minutes.m_value + 1) % 60;
    }
    
    //Write the changed values back to the clock object.
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);  
}
/**
 * @brief Entry function to ISAUTOINCREMENT widget state to set flag for increment at every 250 ms.
 */
static void CLOCK_setAutoIncrement()
{
    SETFLAG(autoIncrement_st);
}
/**
 * @brief Exit function from ISAUTOINCREMENT widget state to reset flag for increment at every 250 ms.
 */
static void CLOCK_resetAutoIncrement()
{
    RESETFLAG(autoIncrement_st);
}
/**
 * @brief Error handler : sets an error event.
 */
static void CLOCK__errorHandler()
{
    UART_LOG_PutString("CLOCK__errorHandler\n");
    
    // Set an error event.
    SC_EVENT_data_t ev = {EV_ERROR};
    RTE_SC_EVENT_set(&SO_EVENT_signal, ev);
}
/**
 * @brief Error handler routine : handling of error is done here.
 */
static void CLOCK__errorHandlerRoutine()
{
    UART_LOG_PutString("CLOCK__errorHandlerRoutine\n");
    
    // Read the clock object
    SC_CLOCK_data_t clock   =   RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    clock.m_containerState  =   STATE_CLOCK_C_ISDISPLAYING; // Set container state to ISDISPLAY.
    clock.m_activeWidget    =   CLOCK_NONE; // No active widget.
    
    CLOCK_widget_t widget;
    widget.m_state          =   STATE_CLOCK_W_ISDISPLAYING; //Set widget state to ISDISPLAY.
    
    CLOCK_font_t font;
    font.foreground         =   WHITE;
    font.background         =   BLACK;
    widget.m_font           =   font;
    
    // retain the hours and minutes values before the error occured.
    widget.m_value          =   clock.m_hours.m_value;
    clock.m_hours           =   widget;
    widget.m_value          =   clock.m_minutes.m_value;
    clock.m_minutes         =   widget;
    
    // Set the clock object after re-initatilzation when error occured.
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
}

/* USER CODE END SWC_CLOCK_CONTROL_FUNCTIONS */

